\section{Design}

Here we give a brief overview of the designs that will be compared.

\subsection{ORAM-inside-MPC}
In the first design, $k$ servers implement ORAM inside of an MPC.
For a client to perform a read, she sends the servers shares
of the index $i$.
The servers then perform an ORAM look-up inside of the MPC.
With the best MPC-ORAM schemes, this can actually be performed
quite efficiently. They then return shares of the value
that was looked up to the client, who reconstructs the value.
Therefore, the communication and computation by the client are $O(1)$.
If the data is initially stored in plaintext, it is necessary
for the data to be inserted into the ORAM by the servers. This requires
about $O(n \log(n))$ computation on behalf of the servers.

This design provides more than PIR. 
Firstly, the servers guarantee that the client only learns a 
single item in the database.
This is therefore a type of \emph{oblivious transfer}, 
a protocol for a party to privately learn an item from an array
while guaranteeing to the provider that only one item was learnt.
(This is a non-standard oblivious transfer implementation 
because the provider consists of multiple servers.)

This design also provides ORAM.
The client state whether the operation to be performed is a read
or a write. If it is a write, the servers can update the ORAM 
inside of the MPC. 
Additionally, regular ORAM is restricted to a single user
but in this scheme, multiple users could access and modify
the same ORAM without needing to share any data between each other.
Of course, if a client were `malicious' and clients were allowed
arbitrary access patterns, then the data and access patterns of
one client could be entirely viewable by another client who
frequently read the entire array.
Adding constraints on how different clients could modify different
areas of memory could allow the construction of interesting
multi-client applications, such as a distributed private file system
or a meta-data private messaging system.

Unlike most PIR schemes, this does not require the servers to
do a linear amount of work (by accessing every data point)
for every query.


\subsection{2-server-PIR-in-MPC}

Another way in which MPC could be used to reduce the client cost in
a PIR protocol is for a regular 2-party PIR to be executed
in which the client is simulated by the MPC. 
The real client would secret share their index between the two
servers. The two servers would then execute a MPC which
simulates the activity of a client engaging in a normal 2-party
PIR protocol. The messages that the client would sent to a server
are revealed to the appropriate server, who can locally perform
the appropriate computations. Any messages from a server to 
the client are fed as secret inputs to the client-simulating-MPC.
Finally, the secret shares of the result are sent to the real 
client. This again requires only $O(1)$ computation and communication
by the client.


\subsection{2-server-PIR-from-1-server-PIR}

Another basic protocol that would allow the user to have
$O(1)$ communication is if one of the 2 servers in a 2-server
PIR scheme were to act as a client for a 1-server PIR scheme
and the other were to act a server. 
The actual client could sent an index to the ``client-server''
who would use that as input to the 1-server PIR.
The client would then send an offset index to the ``server-server''
who would temporarily shift all of the data in their array
by the offset amount. (Or equivalently modify all accesses to their array.)
The ``client-server'' and the ``server-server'' would then
engage in a 1-server PIR protocol.
The ``client-server'' would then forward its message to the client.
To prevent the ``client-server'' from learning the value of the message,
the ``server'' could also temporarily add a random value to each element
of the array. They send this random value to the actual client, who
subtracts it from the value they received from the ``client-server'' 
to obtain the actual data item.

