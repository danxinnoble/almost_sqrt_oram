\section{Efficient, simple, Square-Root ORAM}

The original ORAM paper \cite{ostrovsky1997private} presented a protocol for performing
oblivious-RAM with amortized cost $O(\sqrt{n} \log{n})$.

In the secure-computation setting, a direct application of this
protocol would require many evaluations of an oblivious PRF (OPRF).
While in principle this is a constant-cost operation, in practice evaluating an OPRF is expensive. For instance, in the sem-honest, 2-party setting, the communication cost of oblivious versions of standard PRFs is around 170 Kb and around 20 Kb for MPC-optimized PRFs (\cite{hemenway2019private} Table 1) % This should be updated to reference the actual papers and use more recent results.

A different approach to square-root ORAM was therefore explored by Zahur et al is to use a recursive solution to store a look-up table for the evaluations of the PRF.

We adopt a different approach. We use OPRFs as in the original protocol.
However we take advantage of a number of facts to make the OPRFs more efficient.
Firstly, each PRF will only be evaluated on $\sqrt{n}$ elements.
Therefore, the PRF does not need to be secure up to an arbitrary number of 
evaluations. In deed, it can be rendered completely insecure if evaluated
on $\sqrt(n) + 1$ points and still be secure for our purposes.
Secondly the PRF is evaluated over a small input.
Thirdly, if the PRF is, in fact, a permutation and 
if the function is evaluated for \emph{every} point in the range,
the distribution of the output (when sorted or shuffled again)
does not leak any information about the function.
We achieve this using Feistel's technique to transform a PRF into a PRP.

\subsection{Feistel Cipher}

The Feistel Cipher allows any PRF $F : [m] \rightarrow[m]$ to be transformed
into a PRP $G : [m] \times [m] \rightarrow [m] \times [m]$. The technique is as follows.

Let $i = (L, R)$, where $i \in [m] \times [m]$ and $L, R \in [m]$.
Let $B_k(i) = (R, L + F_k(R))$.
$B_k$ is clearly invertible and maps $[m] \times [m]$ to $[m] \times [m]$, so is a permutation.
However, it is clearly not pseudo-random, since the last element of $i$ 
completely reveals the first element of $B_k(i)$.
Nevertheless, it turns out that if this process is repeated three times,
using three independently chosen keys, the composition is pseudo-random,
i.e. $G_{k_1, k_2, k_3} \defined B_{k_3} \circ B_{k_2} \circ B_{k_1}$ is a PRP
\cite{luby1988construct}.


\subsection{Oblivious Pseudo-random function}

Any OPRF $F : [\sqrt{n}] \rightarrow [\sqrt{n}]$ can be used to 
construct an OPRP $G : [n] \rightarrow [n]$.
For our purposes, it is sufficient to use the simplest possible
OPRF, namely a look-up table on random values.
While this costs $\sqrt{n}$ secure-comparisons and 
$\sqrt{n}$ muxes per OPRF evaluation,
each ORAM read will only require $3$ such evaluations,
and each ORAM shuffle will only require $3 \sqrt{n}$ such evaluations.
This therefore does not affect the asymptotic performance
of the protocol, and the constants are small.

Of course, other OPRFs may be more efficient and since the design
is modular they can easily be substituted in.

\begin{algorithm}
\caption{OPRF}
\label{alg:oprf}
\begin{algorithmic}[1]

\Procedure{OPRF.init}{size} \Comment{For ORAM, $size = \sqrt{n}$}
\For{$i \gets 1$  to $size$} 
    \State $table[i] \gets^r [size]$
\EndFor
\State \textbf{return} self
\EndProcedure

\State

\Procedure{OPRF.eval}{x}
\State $res \gets 0$
\For{$i \gets 1$ to $size$}
    \State obliv\_if $i = x$ then
    \State $res \gets table[i]$
    \State fi
\EndFor
\State \textbf{return} res
\EndProcedure

\end{algorithmic}
\end{algorithm}

\subsection{Oblivious Sorting}

Oblivious sorting is fundamental to many ORAM protocols and is often
a bottle-neck in the secure computation.
However, we can utilize the fact that every sort we do will be sorting
based on an array that contains every possible element exactly once.
Therefore, we can randomly permute the elements first,
then reveal the field to be sorted on and then sort in the clear.

The function takes at least two arguments. 
The first, $A$, is an array of the indices to be sorted on.
Their distribution (but not order) is public and there are no duplicates.
The remaining arguments are arrays of the same length as the index array,
which should be sorted according to the index array.
The protocol is presented in Figure~\ref{fig:OblivSort}.


\begin{algorithm}
\caption{oblivSort: Sort based on indexes with a public distribution}
\label{fig:OblivSort}
\begin{algorithmic}[0]

\Procedure{oblivSort}{A, B}
\State $(\hat{A} , \hat{B}) = shuffle(A, B)$
\State $\tilde{A} = reveal(\hat{A})$
\State $\bar{B} = sort(\tilde{A}, \hat{B})$
\State \textbf{return} $\bar{B}$
\EndProcedure

\end{algorithmic}
\end{algorithm}

\subsection{Random Shuffle}

There are many protocols for a random shuffle.
We will use a Waksman permutation network.
\footnote{Waksman permutation networks are very good for shuffling an array,
however evaluating the permutation on a particular point cannot be done
efficiently. Hence, we do not use Waksman networks to perform the ORAM permutation.}
This is a $O(n \log{n})$-sized network of switches that allows computationation
of an arbitrary permutation by setting the switch-bits appropriately.
An important observation is that setting the switch-bits randomly
does not result in a random permutation.
Therefore, for the MPC setting where at most $t$ players are dishonest,
$(t+1)$ players should each choose switch-bits and have a Waksman permutation
evaluated on the array, in turn, using these switch bits.  
In an arithmetic ciruit MPC framework, this can be done using $O( (t+1) n \log{n})$ multiplications.


\subsection{Construction}

\begin{algorithm}
\caption{OblivSet}
\label{alg:obliv_set}
\begin{algorithmic}[1]

\Procedure{OblivSet.init}{$max\_size$}  

\State $stash \gets [ \bot $ for $0 \leq i < max\_size]$
\State $nElem \gets 0$
\State \textbf{return} self
\EndProcedure

\State

\Procedure{OblivSet.add}{$(\secret{x}, \secret{y})$} 
\Comment{Assumes fewer than $max\_size$ elements have already been added}
\State $stash[nElem + 1] \gets (\secret{x}, \secret{y})$
\State $nElem \gets nElem + 1$
\EndProcedure

\State

\Procedure{OblivSet.empty}{}
\State $stash \gets [ \bot $ for $0 \leq i < nElem]$
\State $nElem \gets 0$
\EndProcedure

\State

\Procedure{OblivSet.get}{$\secret{key}$}
\State $\secret{res} \gets \bot$
\For{$j \gets 1$ to $nElem$}
    \State $(\secret{x}, \secret{y}) \gets stash[j]$
    \State obliv\_if $\secret{key} = \secret{x}$ then
        \State $\secret{res} \gets \secret{y}$
    \State fi
\EndFor
\State \textbf{return} res
\EndProcedure

\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{SqrtORAM}
\label{alg:oram}
\begin{algorithmic}[1]

\Procedure{SqrtOram.init}{m, data\_orig}
\Comment{$m$ is the size of the array}

\State $n \gets$ smallest $n= p^{2k}$, such that $n - \sqrt{n} > m$, $p$ is prime and $k \in \mathbb{N}$.

\For{ $i \gets 1$ to $m$}
   \State $data[i] = data\_orig[i]$
\EndFor

\For{ $i \gets m+1$ to $n$}
   \State $data[i] = \bot$
\EndFor
   
\For{ $i \gets 1$ to $n$}
    \State $ind[i]  = (\lfloor{ \frac{i}{\sqrt{n}}} \rfloor ,  i \bmod \sqrt{n}) $
\EndFor

\State $count = 0$
\State \textbf{return} self
\EndProcedure

\State

\Procedure{SqrtOram.shuffle}{}

\State $(ind_0, data_0) = OblivSort(ind, (ind, data))$ \label{line:first_sort}

\For{ $k \gets 1, 2, 3$}
    \State $P_i = PRF.init()$ 

    \For{ $j \gets 1$ to $\sqrt{n}$}
        \State $B_k[j] = P_k.eval(j)$ \label{line:prf_eval}
        \For{$i \gets 1$ to $\sqrt{n}$}
            \State $C_k[\sqrt{n} i + j] = (j, i + B_k[j] \bmod \sqrt{n})$
        \EndFor
    \EndFor
 
    \State $(ind_k, data_k) = OblivSort(C_k, (ind_{k-1}, data_{k-1}))$
        \label{line:second_sort}
  
\EndFor

\State $stash \gets OblivSet.init(\sqrt{n})$

% NEED TO CREATE A OPRP OBJECT
  $B_k (L, R) = (R, L + P_k(R))$

\State \textbf{return} self

\EndProcedure

\State

\algstore{myalg}

\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\begin{algorithmic}[1]
\algrestore{myalg}

\Procedure{SqrtOram.Access}{i}

\If{$count = 0$}
    \State this.shuffle()
\EndIf

\State $res \gets stash.get(i)$

\If{ $res \neq \bot$}
    \State $p \gets oprp.eval(m + count)$
\Else
    \State $p \gets oprp.eval(i)$
\EndIf

\State $datum \gets data[p]$
\State $stash.add((i, datum))$

\If{ $res \neq \bot$ }
    \State $res \gets res$
\Else
    \State $res \gets datum$
\EndIf

\State $count \gets count + 1 \bmod \sqrt{n}$ 

\State \textbf{return} res
\EndProcedure

\end{algorithmic}
\end{algorithm}


The construction follows the original square-root ORAM construction
\cite{ostrovsky1997private} in general. 
However it has a much more efficient shuffling step.

The original ORAM construction stores each item element $i$
in a secret location, $OPRF_k(i)$, in a table where
the key, $k$, for the PRF is secret and the PRF is evaluated obliviously.
In order to avoid leakage from accessing the same element twice,
accessed elements are stored in a stash. 
In each access, the item is first searched for in the stash.
If it found there, then a dummy item is accessed in the table.

In order to efficiently reshuffle the table, we use a Feistel-constructed
PRP as the PRF.

The critical observation if, $B_k : [n] \rightarrow [n]$ is a permutation, 
then the set $\{B_k(j) \}_{j=1 \ldots n} = \{j = 1 \ldots n\}$.
Therefore, revealing the contents (though not the order) of
$\{B_k(j)\}_{j=1 \ldots n}$ reveals nothing.

We use this fact in the OblivSort function in Algorithm \ref{fig:OblivSort}.
The data is first shuffled using several Waksman permutation networks
(one from each player).
Then the evaluations of $B_k$ are revealed and sorting is performed in the clear
(carrying the corresponding payloads).

To perform the psuedo-random permutation on every element, 
each of the three permutations, $B_1$, $B_2$ and $B_3$ are applied in turn.
The payload is always kept secret. 
To apply $B_k$, the corresponding OPRF, $P_k$ is applied to every possible string
in $[\sqrt{n}]$. 
